# MGraph-AI Service Deploy - MVP Brief

## Document Information

| Field | Value |
|-------|-------|
| Service | MGraph-AI Service Deploy |
| Version | v0.1.0 (MVP) |
| Target Deployment | https://deploy.dev.mgraph.ai/ |
| Repository | `the-cyber-boardroom/MGraph-AI__Service__Deploy` |
| Document Type | LLM Implementation Brief |
| Last Updated | December 2025 |

---

## 1. Executive Summary

### 1.1 What Is This?

The **MGraph-AI Service Deploy** is an API-driven orchestration service that executes deployment operations across cloud providers. This MVP focuses specifically on **GitHub Secrets management** - the ability to programmatically configure secrets in a GitHub repository from an external client.

### 1.2 The Problem Being Solved

You have a new GitHub repository with a CI pipeline that needs 6 secrets configured before it can deploy (AWS credentials, API keys, etc.). Currently this requires:
- Manual clicks in GitHub UI, or
- Expensive tools like Terraform, or
- Custom scripts with poor security practices

### 1.3 The Solution

A **Deploy Service** that:
1. Runs as an independent Lambda function (`deploy.dev.mgraph.ai`)
2. Accepts encrypted credentials (never sees raw secrets)
3. Proxies operations to the GitHub Service
4. Allows batch execution via workflow files

### 1.4 Key Insight: Pass-Through Security Model

The Deploy Service **never decrypts any credentials**. It acts as a secure proxy:

```
┌─────────────────────────────────────────────────────────────────────────┐
│  CLIENT                                                                  │
│  - Has raw GitHub PAT                                                   │
│  - Has raw secret values (AWS creds, etc.)                              │
│  - Encrypts everything locally using GitHub Service's public key        │
└─────────────────────────────────────┬───────────────────────────────────┘
                                      │ encrypted PAT + encrypted values
                                      ▼
┌─────────────────────────────────────────────────────────────────────────┐
│  DEPLOY SERVICE (deploy.dev.mgraph.ai)                                  │
│  - Receives encrypted blobs                                              │
│  - Passes them through unchanged                                         │
│  - NEVER decrypts (has no private key)                                  │
│  - Even if compromised, attacker sees only encrypted data               │
└─────────────────────────────────────┬───────────────────────────────────┘
                                      │ encrypted PAT + encrypted values (unchanged)
                                      ▼
┌─────────────────────────────────────────────────────────────────────────┐
│  GITHUB SERVICE (github.dev.mgraph.ai)                                  │
│  - Has the private key                                                   │
│  - Decrypts PAT and secret values                                       │
│  - Calls GitHub API                                                      │
└─────────────────────────────────────┬───────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────┐
│  TARGET GITHUB REPO                                                     │
│  - Receives the secrets                                                  │
│  - CI pipeline can now deploy                                           │
└─────────────────────────────────────────────────────────────────────────┘
```

**Security benefit**: The Deploy Service has a reduced attack surface. Even if fully compromised, an attacker cannot extract usable credentials - they only see encrypted blobs that can only be decrypted by the GitHub Service.

---

## 2. Architecture

### 2.1 Service Dependencies

| Service | URL | Purpose |
|---------|-----|---------|
| GitHub Service | `https://github.dev.mgraph.ai/` | GitHub API operations (secrets CRUD) |
| Deploy Service | `https://deploy.dev.mgraph.ai/` | Orchestration layer (TO BUILD) |

### 2.2 The Three Entities

1. **Client** - Developer laptop or CI pipeline that has access to raw credentials
2. **Deploy Service** - Pass-through orchestration layer (this MVP)
3. **GitHub Service** - Existing service that holds private key and calls GitHub API

### 2.3 Data Flow

```
1. Client calls Deploy Service: GET /public-keys/github
   │
   ▼
2. Deploy Service proxies to GitHub Service: GET /encryption/public-key
   │
   ▼
3. Client receives public key (hex string)
   │
   ▼
4. Client encrypts PAT locally using NaCl SealedBox
   │
   ▼
5. Client encrypts secret values locally using same public key
   │
   ▼
6. Client calls Deploy Service: POST /operations/github/secrets/create
   Body: { encrypted_pat, target: {owner, repo}, secret_name, encrypted_value }
   │
   ▼
7. Deploy Service transforms and proxies to GitHub Service:
   POST /github-secrets-repo/create
   Body: { encrypted_pat, request_data: {owner, repo, secret_name, encrypted_value} }
   │
   ▼
8. GitHub Service decrypts, calls GitHub API, returns result
   │
   ▼
9. Deploy Service returns result to client
```

---

## 3. MVP Phases

### 3.1 Phase 1: Direct Operations

Expose individual operations as REST endpoints. The client calls one operation at a time.

### 3.2 Phase 2: Workflow File Execution

Accept a JSON workflow file containing encrypted credentials and a list of operations. Execute them in sequence and return aggregate results.

---

## 4. Phase 1: Direct Operations API

### 4.1 Routes Overview

| Endpoint | Method | Description |
|----------|--------|-------------|
| `/public-keys/github` | GET | Proxy GitHub Service's public key |
| `/operations/github/secrets/list` | POST | List secrets in a repo |
| `/operations/github/secrets/get` | POST | Get metadata for a single secret |
| `/operations/github/secrets/exists` | POST | Check if a secret exists |
| `/operations/github/secrets/create` | POST | Create or update a secret |
| `/operations/github/secrets/delete` | POST | Delete a secret |

### 4.2 Route: Get GitHub Public Key

```http
GET /public-keys/github
```

**Response:**
```json
{
    "public_key": "a1b2c3d4e5f6...64_hex_characters...",
    "algorithm": "NaCl/Curve25519/SealedBox",
    "service": "github"
}
```

**Implementation:** Proxy call to `GET https://github.dev.mgraph.ai/encryption/public-key`

### 4.3 Route: List Secrets

```http
POST /operations/github/secrets/list
Content-Type: application/json

{
    "encrypted_pat": "<base64_encrypted_pat>",
    "target": {
        "owner": "the-cyber-boardroom",
        "repo": "my-new-service"
    }
}
```

**Response:**
```json
{
    "success": true,
    "operation": "github:secrets:list",
    "data": {
        "secrets": [
            {"name": "AWS_ACCOUNT_ID", "created_at": "...", "updated_at": "..."},
            {"name": "AWS_ACCESS_KEY_ID", "created_at": "...", "updated_at": "..."}
        ]
    },
    "duration": 0.234,
    "rate_limit": {
        "remaining": 4998,
        "limit": 5000
    }
}
```

**Implementation:** Transform and proxy to `POST https://github.dev.mgraph.ai/github-secrets-repo/list`

### 4.4 Route: Get Secret

```http
POST /operations/github/secrets/get
Content-Type: application/json

{
    "encrypted_pat": "<base64_encrypted_pat>",
    "target": {
        "owner": "the-cyber-boardroom",
        "repo": "my-new-service"
    },
    "secret_name": "AWS_ACCOUNT_ID"
}
```

**Response:**
```json
{
    "success": true,
    "operation": "github:secrets:get",
    "data": {
        "secret": {
            "name": "AWS_ACCOUNT_ID",
            "created_at": "2024-01-15T10:30:00Z",
            "updated_at": "2024-03-20T14:45:00Z"
        }
    }
}
```

### 4.5 Route: Check Secret Exists

```http
POST /operations/github/secrets/exists
Content-Type: application/json

{
    "encrypted_pat": "<base64_encrypted_pat>",
    "target": {
        "owner": "the-cyber-boardroom",
        "repo": "my-new-service"
    },
    "secret_name": "AWS_ACCOUNT_ID"
}
```

**Response:**
```json
{
    "success": true,
    "operation": "github:secrets:exists",
    "data": {
        "exists": true,
        "secret_name": "AWS_ACCOUNT_ID"
    }
}
```

**Implementation:** Call `/github-secrets-repo/get`, return `exists: true` if found, `exists: false` if 404.

### 4.6 Route: Create Secret

```http
POST /operations/github/secrets/create
Content-Type: application/json

{
    "encrypted_pat": "<base64_encrypted_pat>",
    "target": {
        "owner": "the-cyber-boardroom",
        "repo": "my-new-service"
    },
    "secret_name": "AWS_ACCOUNT_ID",
    "encrypted_value": "<base64_encrypted_secret_value>"
}
```

**Response:**
```json
{
    "success": true,
    "operation": "github:secrets:create",
    "data": {
        "created": true,
        "secret_name": "AWS_ACCOUNT_ID"
    },
    "messages": ["Secret 'AWS_ACCOUNT_ID' created"]
}
```

**Implementation:** Transform and proxy to `POST https://github.dev.mgraph.ai/github-secrets-repo/create`

### 4.7 Route: Delete Secret

```http
POST /operations/github/secrets/delete
Content-Type: application/json

{
    "encrypted_pat": "<base64_encrypted_pat>",
    "target": {
        "owner": "the-cyber-boardroom",
        "repo": "my-new-service"
    },
    "secret_name": "OLD_SECRET"
}
```

**Response:**
```json
{
    "success": true,
    "operation": "github:secrets:delete",
    "data": {
        "deleted": true,
        "secret_name": "OLD_SECRET"
    }
}
```

---

## 5. Phase 2: Workflow File Execution

### 5.1 Workflow File Structure

The workflow file is a JSON document that contains:
1. **Encrypted credentials** at the top (encrypted by client before sending)
2. **Operations list** to execute in sequence

```json
{
    "credentials": {
        "github_pat": "<base64_encrypted_pat>"
    },
    "target": {
        "owner": "the-cyber-boardroom",
        "repo": "my-new-service"
    },
    "operations": [
        {
            "type": "github:secrets:create",
            "secret_name": "AWS_ACCOUNT_ID",
            "encrypted_value": "<base64_encrypted_value>"
        },
        {
            "type": "github:secrets:create",
            "secret_name": "AWS_DEFAULT_REGION",
            "encrypted_value": "<base64_encrypted_value>"
        },
        {
            "type": "github:secrets:create",
            "secret_name": "AWS_ACCESS_KEY_ID",
            "encrypted_value": "<base64_encrypted_value>"
        },
        {
            "type": "github:secrets:create",
            "secret_name": "AWS_SECRET_ACCESS_KEY",
            "encrypted_value": "<base64_encrypted_value>"
        },
        {
            "type": "github:secrets:create",
            "secret_name": "FAST_API__AUTH__API_KEY__NAME",
            "encrypted_value": "<base64_encrypted_value>"
        },
        {
            "type": "github:secrets:create",
            "secret_name": "FAST_API__AUTH__API_KEY__VALUE",
            "encrypted_value": "<base64_encrypted_value>"
        }
    ]
}
```

### 5.2 Routes Overview

| Endpoint | Method | Description |
|----------|--------|-------------|
| `/execute` | POST | Execute a workflow file |
| `/execute/plan` | POST | Dry-run - show what would happen |

### 5.3 Route: Execute Workflow

```http
POST /execute
Content-Type: application/json

{
    "credentials": { ... },
    "target": { ... },
    "operations": [ ... ]
}
```

**Response:**
```json
{
    "success": true,
    "total_operations": 6,
    "completed": 6,
    "failed": 0,
    "duration": 2.456,
    "results": [
        {
            "operation": "github:secrets:create",
            "secret_name": "AWS_ACCOUNT_ID",
            "success": true,
            "duration": 0.412
        },
        {
            "operation": "github:secrets:create",
            "secret_name": "AWS_DEFAULT_REGION",
            "success": true,
            "duration": 0.389
        },
        // ... more results
    ]
}
```

### 5.4 Route: Plan (Dry Run)

```http
POST /execute/plan
Content-Type: application/json

{
    "credentials": { ... },
    "target": { ... },
    "operations": [ ... ]
}
```

**Response:**
```json
{
    "valid": true,
    "total_operations": 6,
    "plan": [
        {
            "step": 1,
            "operation": "github:secrets:create",
            "secret_name": "AWS_ACCOUNT_ID",
            "target": "the-cyber-boardroom/my-new-service"
        },
        {
            "step": 2,
            "operation": "github:secrets:create",
            "secret_name": "AWS_DEFAULT_REGION",
            "target": "the-cyber-boardroom/my-new-service"
        },
        // ... more steps
    ],
    "warnings": [],
    "errors": []
}
```

---

## 6. Schema Definitions

### 6.1 Base Schemas

```python
from typing                          import List, Optional
from osbot_utils.type_safe.Type_Safe import Type_Safe

class Schema__Target__GitHub__Repo(Type_Safe):                    # Target repository for operations
    owner : str                                                   # Repository owner (user or org)
    repo  : str                                                   # Repository name


class Schema__Operation__Result(Type_Safe):                       # Result of a single operation
    success      : bool                        = False            # Whether operation succeeded
    operation    : str                         = ''               # Operation type (e.g., 'github:secrets:create')
    duration     : Optional[float]             = None             # Execution time in seconds
    data         : Optional[dict]              = None             # Operation-specific result data
    messages     : List[str]                                      # Informational messages
    errors       : List[str]                                      # Error messages if failed
    rate_limit   : Optional[dict]              = None             # GitHub rate limit info
```

### 6.2 Request Schemas - Phase 1

```python
class Schema__Request__Public_Keys__GitHub(Type_Safe):            # Request for GitHub public key
    pass                                                          # No body required (GET request)


class Schema__Request__GitHub__Secrets__List(Type_Safe):          # Request to list secrets
    encrypted_pat : str                                           # Base64 NaCl-encrypted GitHub PAT
    target        : Schema__Target__GitHub__Repo                  # Target repository


class Schema__Request__GitHub__Secrets__Get(Type_Safe):           # Request to get a secret
    encrypted_pat : str                                           # Base64 NaCl-encrypted GitHub PAT
    target        : Schema__Target__GitHub__Repo                  # Target repository
    secret_name   : str                                           # Name of the secret


class Schema__Request__GitHub__Secrets__Exists(Type_Safe):        # Request to check if secret exists
    encrypted_pat : str                                           # Base64 NaCl-encrypted GitHub PAT
    target        : Schema__Target__GitHub__Repo                  # Target repository
    secret_name   : str                                           # Name of the secret


class Schema__Request__GitHub__Secrets__Create(Type_Safe):        # Request to create a secret
    encrypted_pat   : str                                         # Base64 NaCl-encrypted GitHub PAT
    target          : Schema__Target__GitHub__Repo                # Target repository
    secret_name     : str                                         # Name of the secret
    encrypted_value : str                                         # Base64 NaCl-encrypted secret value


class Schema__Request__GitHub__Secrets__Delete(Type_Safe):        # Request to delete a secret
    encrypted_pat : str                                           # Base64 NaCl-encrypted GitHub PAT
    target        : Schema__Target__GitHub__Repo                  # Target repository
    secret_name   : str                                           # Name of the secret
```

### 6.3 Request Schemas - Phase 2

```python
class Schema__Workflow__Credentials(Type_Safe):                   # Encrypted credentials for workflow
    github_pat : str                                              # Base64 NaCl-encrypted GitHub PAT


class Schema__Workflow__Operation(Type_Safe):                     # Single operation in a workflow
    type            : str                                         # Operation type (e.g., 'github:secrets:create')
    secret_name     : Optional[str]              = None           # Secret name (for secrets operations)
    encrypted_value : Optional[str]              = None           # Encrypted value (for create/update)


class Schema__Request__Execute(Type_Safe):                        # Request to execute a workflow
    credentials : Schema__Workflow__Credentials                   # Encrypted credentials
    target      : Schema__Target__GitHub__Repo                    # Target repository
    operations  : List[Schema__Workflow__Operation]               # Operations to execute


class Schema__Response__Execute(Type_Safe):                       # Response from workflow execution
    success          : bool                      = False          # Overall success
    total_operations : int                       = 0              # Total operations in workflow
    completed        : int                       = 0              # Successfully completed
    failed           : int                       = 0              # Failed operations
    duration         : float                     = 0.0            # Total execution time
    results          : List[dict]                                 # Per-operation results
```

---

## 7. Service Implementation

### 7.1 GitHub Service Client

A client class that handles communication with the GitHub Service:

```python
from osbot_utils.type_safe.Type_Safe import Type_Safe
from requests                        import Session

GITHUB_SERVICE_URL = 'https://github.dev.mgraph.ai'

class GitHub__Service__Client(Type_Safe):                         # Client for GitHub Service
    service_url : str     = GITHUB_SERVICE_URL
    session     : Session = None
    
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        if self.session is None:
            self.session = Session()
    
    def get_public_key(self) -> dict:                             # Fetch GitHub Service's public key
        response = self.session.get(f"{self.service_url}/encryption/public-key")
        response.raise_for_status()
        return response.json()
    
    def list_secrets(self, encrypted_pat: str,                    # List secrets in a repository
                           owner: str, 
                           repo: str) -> dict:
        payload = {
            "encrypted_pat": encrypted_pat,
            "request_data": {
                "owner": owner,
                "repo": repo
            }
        }
        response = self.session.post(
            f"{self.service_url}/github-secrets-repo/list",
            json=payload
        )
        return response.json()
    
    def get_secret(self, encrypted_pat: str,                      # Get a single secret's metadata
                         owner: str, 
                         repo: str,
                         secret_name: str) -> dict:
        payload = {
            "encrypted_pat": encrypted_pat,
            "request_data": {
                "owner": owner,
                "repo": repo,
                "secret_name": secret_name
            }
        }
        response = self.session.post(
            f"{self.service_url}/github-secrets-repo/get",
            json=payload
        )
        return response.json()
    
    def create_secret(self, encrypted_pat: str,                   # Create or update a secret
                            owner: str, 
                            repo: str,
                            secret_name: str,
                            encrypted_value: str) -> dict:
        payload = {
            "encrypted_pat": encrypted_pat,
            "request_data": {
                "owner": owner,
                "repo": repo,
                "secret_name": secret_name,
                "encrypted_value": encrypted_value
            }
        }
        response = self.session.post(
            f"{self.service_url}/github-secrets-repo/create",
            json=payload
        )
        return response.json()
    
    def delete_secret(self, encrypted_pat: str,                   # Delete a secret
                            owner: str, 
                            repo: str,
                            secret_name: str) -> dict:
        payload = {
            "encrypted_pat": encrypted_pat,
            "request_data": {
                "owner": owner,
                "repo": repo,
                "secret_name": secret_name
            }
        }
        response = self.session.delete(
            f"{self.service_url}/github-secrets-repo/delete",
            json=payload
        )
        return response.json()
```

### 7.2 Routes Implementation

```python
from osbot_fast_api.api.routes.Fast_API__Routes import Fast_API__Routes
from mgraph_ai_service_deploy.service.GitHub__Service__Client import GitHub__Service__Client

TAG__ROUTES_PUBLIC_KEYS = 'public-keys'

class Routes__Public_Keys(Fast_API__Routes):                      # Routes for public key retrieval
    tag           : str                     = TAG__ROUTES_PUBLIC_KEYS
    github_client : GitHub__Service__Client
    
    def github(self):                                             # Get GitHub Service's public key
        result = self.github_client.get_public_key()
        return {
            "public_key" : result.get("public_key"),
            "algorithm"  : result.get("algorithm", "NaCl/Curve25519/SealedBox"),
            "service"    : "github"
        }
    
    def setup_routes(self):
        self.add_route_get(self.github)


TAG__ROUTES_OPERATIONS_GITHUB_SECRETS = 'operations-github-secrets'

class Routes__Operations__GitHub__Secrets(Fast_API__Routes):      # Routes for GitHub Secrets operations
    tag           : str                     = TAG__ROUTES_OPERATIONS_GITHUB_SECRETS
    github_client : GitHub__Service__Client
    
    def list(self, request: Schema__Request__GitHub__Secrets__List
             ) -> Schema__Operation__Result:
        github_response = self.github_client.list_secrets(
            encrypted_pat = request.encrypted_pat,
            owner         = request.target.owner,
            repo          = request.target.repo
        )
        return self._transform_response('github:secrets:list', github_response)
    
    def get(self, request: Schema__Request__GitHub__Secrets__Get
            ) -> Schema__Operation__Result:
        github_response = self.github_client.get_secret(
            encrypted_pat = request.encrypted_pat,
            owner         = request.target.owner,
            repo          = request.target.repo,
            secret_name   = request.secret_name
        )
        return self._transform_response('github:secrets:get', github_response)
    
    def exists(self, request: Schema__Request__GitHub__Secrets__Exists
               ) -> Schema__Operation__Result:
        github_response = self.github_client.get_secret(
            encrypted_pat = request.encrypted_pat,
            owner         = request.target.owner,
            repo          = request.target.repo,
            secret_name   = request.secret_name
        )
        
        context = github_response.get('response_context', {})
        exists  = context.get('success', False)
        
        return Schema__Operation__Result(
            success   = True,
            operation = 'github:secrets:exists',
            data      = {'exists': exists, 'secret_name': request.secret_name}
        )
    
    def create(self, request: Schema__Request__GitHub__Secrets__Create
               ) -> Schema__Operation__Result:
        github_response = self.github_client.create_secret(
            encrypted_pat   = request.encrypted_pat,
            owner           = request.target.owner,
            repo            = request.target.repo,
            secret_name     = request.secret_name,
            encrypted_value = request.encrypted_value
        )
        return self._transform_response('github:secrets:create', github_response)
    
    def delete(self, request: Schema__Request__GitHub__Secrets__Delete
               ) -> Schema__Operation__Result:
        github_response = self.github_client.delete_secret(
            encrypted_pat = request.encrypted_pat,
            owner         = request.target.owner,
            repo          = request.target.repo,
            secret_name   = request.secret_name
        )
        return self._transform_response('github:secrets:delete', github_response)
    
    def _transform_response(self, operation: str, github_response: dict
                            ) -> Schema__Operation__Result:
        context = github_response.get('response_context', {})
        data    = github_response.get('response_data', {})
        
        return Schema__Operation__Result(
            success    = context.get('success', False),
            operation  = operation,
            duration   = context.get('duration'),
            data       = data,
            messages   = context.get('messages', []),
            errors     = context.get('errors', []),
            rate_limit = context.get('rate_limit')
        )
    
    def setup_routes(self):
        self.add_route_post(self.list  )
        self.add_route_post(self.get   )
        self.add_route_post(self.exists)
        self.add_route_post(self.create)
        self.add_route_post(self.delete)
```

### 7.3 Workflow Execution Service

```python
from typing                          import List
from osbot_utils.type_safe.Type_Safe import Type_Safe
from osbot_utils.helpers.duration.decorators.capture_duration import capture_duration

class Service__Workflow__Executor(Type_Safe):                     # Executes workflow files
    github_client : GitHub__Service__Client
    
    def execute(self, request: Schema__Request__Execute
                ) -> Schema__Response__Execute:
        results   = []
        completed = 0
        failed    = 0
        
        with capture_duration() as duration:
            for operation in request.operations:
                result = self._execute_operation(
                    operation     = operation,
                    encrypted_pat = request.credentials.github_pat,
                    target        = request.target
                )
                results.append(result)
                
                if result.get('success'):
                    completed += 1
                else:
                    failed += 1
        
        return Schema__Response__Execute(
            success          = (failed == 0),
            total_operations = len(request.operations),
            completed        = completed,
            failed           = failed,
            duration         = duration.seconds,
            results          = results
        )
    
    def plan(self, request: Schema__Request__Execute) -> dict:    # Dry run - show what would happen
        plan_steps = []
        
        for i, operation in enumerate(request.operations, 1):
            plan_steps.append({
                "step"        : i,
                "operation"   : operation.type,
                "secret_name" : operation.secret_name,
                "target"      : f"{request.target.owner}/{request.target.repo}"
            })
        
        return {
            "valid"            : True,
            "total_operations" : len(request.operations),
            "plan"             : plan_steps,
            "warnings"         : [],
            "errors"           : []
        }
    
    def _execute_operation(self, operation: Schema__Workflow__Operation,
                                 encrypted_pat: str,
                                 target: Schema__Target__GitHub__Repo) -> dict:
        
        with capture_duration() as duration:
            if operation.type == 'github:secrets:create':
                response = self.github_client.create_secret(
                    encrypted_pat   = encrypted_pat,
                    owner           = target.owner,
                    repo            = target.repo,
                    secret_name     = operation.secret_name,
                    encrypted_value = operation.encrypted_value
                )
            elif operation.type == 'github:secrets:delete':
                response = self.github_client.delete_secret(
                    encrypted_pat = encrypted_pat,
                    owner         = target.owner,
                    repo          = target.repo,
                    secret_name   = operation.secret_name
                )
            elif operation.type == 'github:secrets:list':
                response = self.github_client.list_secrets(
                    encrypted_pat = encrypted_pat,
                    owner         = target.owner,
                    repo          = target.repo
                )
            else:
                return {
                    "operation"   : operation.type,
                    "secret_name" : operation.secret_name,
                    "success"     : False,
                    "error"       : f"Unknown operation type: {operation.type}"
                }
        
        context = response.get('response_context', {})
        return {
            "operation"   : operation.type,
            "secret_name" : operation.secret_name,
            "success"     : context.get('success', False),
            "duration"    : duration.seconds
        }
```

---

## 8. File Structure

```
MGraph-AI__Service__Deploy/
├── mgraph_ai_service_deploy/
│   ├── __init__.py
│   ├── config.py
│   ├── version
│   │
│   ├── fast_api/
│   │   ├── __init__.py
│   │   ├── Deploy__Service__Fast_API.py
│   │   ├── lambda_handler.py
│   │   │
│   │   └── routes/
│   │       ├── __init__.py
│   │       ├── Routes__Public_Keys.py
│   │       ├── Routes__Operations__GitHub__Secrets.py
│   │       └── Routes__Execute.py
│   │
│   ├── schemas/
│   │   ├── __init__.py
│   │   ├── base/
│   │   │   ├── Schema__Target__GitHub__Repo.py
│   │   │   └── Schema__Operation__Result.py
│   │   │
│   │   ├── operations/
│   │   │   ├── Schema__Request__GitHub__Secrets__List.py
│   │   │   ├── Schema__Request__GitHub__Secrets__Get.py
│   │   │   ├── Schema__Request__GitHub__Secrets__Exists.py
│   │   │   ├── Schema__Request__GitHub__Secrets__Create.py
│   │   │   └── Schema__Request__GitHub__Secrets__Delete.py
│   │   │
│   │   └── workflow/
│   │       ├── Schema__Workflow__Credentials.py
│   │       ├── Schema__Workflow__Operation.py
│   │       ├── Schema__Request__Execute.py
│   │       └── Schema__Response__Execute.py
│   │
│   ├── service/
│   │   ├── __init__.py
│   │   ├── GitHub__Service__Client.py
│   │   └── Service__Workflow__Executor.py
│   │
│   └── utils/
│       ├── __init__.py
│       ├── Version.py
│       └── deploy/
│           └── Deploy__Service.py
│
├── tests/
│   ├── unit/
│   │   ├── test_GitHub__Service__Client.py
│   │   ├── test_Service__Workflow__Executor.py
│   │   └── test_schemas.py
│   │
│   ├── integration/
│   │   └── test_Routes__Operations__GitHub__Secrets.py
│   │
│   └── qa/
│       └── test_Deploy__Service__QA.py
│
├── pyproject.toml
├── README.md
└── .github/
    └── workflows/
        └── ci.yaml
```

---

## 9. Client Usage Example

### 9.1 Python Client for Deploy Service

```python
import base64
import os
from nacl.public import PublicKey, SealedBox
import requests

class Deploy__Service__Client:
    """Client for MGraph-AI Deploy Service."""
    
    def __init__(self, deploy_service_url: str = "https://deploy.dev.mgraph.ai"):
        self.deploy_service_url = deploy_service_url
        self.session            = requests.Session()
        self._public_key        = None
    
    def get_github_public_key(self) -> str:
        """Fetch GitHub Service's public key via Deploy Service."""
        if self._public_key is None:
            response = self.session.get(f"{self.deploy_service_url}/public-keys/github")
            response.raise_for_status()
            self._public_key = response.json()["public_key"]
        return self._public_key
    
    def encrypt(self, value: str) -> str:
        """Encrypt a value using the GitHub Service's public key."""
        public_key_hex   = self.get_github_public_key()
        public_key_bytes = bytes.fromhex(public_key_hex)
        public_key       = PublicKey(public_key_bytes)
        sealed_box       = SealedBox(public_key)
        encrypted        = sealed_box.encrypt(value.encode('utf-8'))
        return base64.b64encode(encrypted).decode('utf-8')
    
    def create_secret(self, owner: str, repo: str, 
                      secret_name: str, secret_value: str,
                      github_pat: str) -> dict:
        """Create a secret in a GitHub repository."""
        payload = {
            "encrypted_pat": self.encrypt(github_pat),
            "target": {
                "owner": owner,
                "repo": repo
            },
            "secret_name": secret_name,
            "encrypted_value": self.encrypt(secret_value)
        }
        response = self.session.post(
            f"{self.deploy_service_url}/operations/github/secrets/create",
            json=payload
        )
        return response.json()
    
    def execute_workflow(self, owner: str, repo: str,
                         secrets: dict, github_pat: str) -> dict:
        """Execute a workflow to create multiple secrets."""
        operations = []
        for name, value in secrets.items():
            operations.append({
                "type": "github:secrets:create",
                "secret_name": name,
                "encrypted_value": self.encrypt(value)
            })
        
        payload = {
            "credentials": {
                "github_pat": self.encrypt(github_pat)
            },
            "target": {
                "owner": owner,
                "repo": repo
            },
            "operations": operations
        }
        
        response = self.session.post(
            f"{self.deploy_service_url}/execute",
            json=payload
        )
        return response.json()


# ═══════════════════════════════════════════════════════════════════════
# Usage Example
# ═══════════════════════════════════════════════════════════════════════

if __name__ == "__main__":
    client = Deploy__Service__Client()
    
    # Get credentials from environment
    github_pat = os.environ["GITHUB_PAT"]
    
    # Define secrets to create
    secrets = {
        "AWS_ACCOUNT_ID"              : os.environ["AWS_ACCOUNT_ID"],
        "AWS_DEFAULT_REGION"          : os.environ["AWS_DEFAULT_REGION"],
        "AWS_ACCESS_KEY_ID"           : os.environ["AWS_ACCESS_KEY_ID"],
        "AWS_SECRET_ACCESS_KEY"       : os.environ["AWS_SECRET_ACCESS_KEY"],
        "FAST_API__AUTH__API_KEY__NAME" : os.environ["FAST_API__AUTH__API_KEY__NAME"],
        "FAST_API__AUTH__API_KEY__VALUE": os.environ["FAST_API__AUTH__API_KEY__VALUE"],
    }
    
    # Execute workflow
    result = client.execute_workflow(
        owner      = "the-cyber-boardroom",
        repo       = "my-new-service",
        secrets    = secrets,
        github_pat = github_pat
    )
    
    if result["success"]:
        print(f"✅ Created {result['completed']} secrets in {result['duration']:.2f}s")
    else:
        print(f"❌ Failed: {result['failed']} of {result['total_operations']} operations failed")
        for r in result["results"]:
            if not r["success"]:
                print(f"   - {r['secret_name']}: {r.get('error', 'Unknown error')}")
```

---

## 10. Deployment

### 10.1 Lambda Configuration

Same pattern as GitHub Service:

```python
# config.py
SERVICE_NAME                         = 'mgraph_ai_service_deploy'
FAST_API__TITLE                      = "MGraph-AI Service Deploy"
FAST_API__DESCRIPTION                = "Infrastructure deployment orchestration service"

LAMBDA_DEPENDENCIES__SERVICE__DEPLOY = ['osbot-fast-api-serverless==v1.32.0',
                                        'requests']

DEPLOY__GITHUB__REPO__OWNER          = 'the-cyber-boardroom'
DEPLOY__GITHUB__REPO__NAME           = 'MGraph-AI__Service__Deploy'

GITHUB_SERVICE_URL                   = 'https://github.dev.mgraph.ai'
```

### 10.2 Deploy to Lambda

```bash
# From the repo root
python -c "from mgraph_ai_service_deploy.utils.deploy.Deploy__Service import Deploy__Service; Deploy__Service().deploy_lambda()"
```

---

## 11. Success Criteria

The MVP is complete when:

1. ✅ Deploy Service deployed to `https://deploy.dev.mgraph.ai/`
2. ✅ `GET /public-keys/github` returns GitHub Service's public key
3. ✅ `POST /operations/github/secrets/list` lists secrets in a repo
4. ✅ `POST /operations/github/secrets/exists` checks if a secret exists
5. ✅ `POST /operations/github/secrets/create` creates/updates a secret
6. ✅ `POST /operations/github/secrets/delete` deletes a secret
7. ✅ `POST /execute` executes a workflow file with multiple operations
8. ✅ `POST /execute/plan` shows what a workflow would do without executing
9. ✅ All credentials remain encrypted end-to-end (Deploy Service never decrypts)
10. ✅ Client example successfully creates 6 secrets in target repo
11. ✅ Unit tests passing
12. ✅ Integration tests against deployed service passing

---

## 12. Future Extensions (Not in MVP)

After MVP is complete, the following can be added:

| Feature | Description |
|---------|-------------|
| Environment secrets | Support for GitHub environment secrets (staging, production) |
| Organization secrets | Support for GitHub organization secrets |
| AWS operations | Lambda, S3, IAM operations via AWS Service |
| MGraph storage | Store execution history in Graph Service |
| Cache integration | Store logs and outputs in Cache Service |
| Dependency resolution | Complex operation graphs with edges |
| Resume/rollback | Continue from failures, undo operations |

---

## 13. Summary

This MVP delivers a **working Deploy Service** that:

1. **Runs independently** at `deploy.dev.mgraph.ai`
2. **Proxies GitHub secrets operations** to the existing GitHub Service
3. **Never sees raw credentials** - pure pass-through model
4. **Supports both direct operations and workflow files**
5. **Enables programmatic CI pipeline configuration** from external clients

The service follows the same patterns as the GitHub Service (Type_Safe, OSBot-Fast-API, Lambda deployment) and sets the foundation for future expansion to AWS operations and full graph-based execution.
