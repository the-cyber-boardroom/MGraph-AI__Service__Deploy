# Surrogate Dependencies - Development Guide

**Purpose**: Guide for LLMs building surrogate dependencies using OSBot Fast_API and Type_Safe  
**Scope**: Creating testable surrogates that simulate external APIs for offline-first development  
**Prerequisites**: Type_Safe documentation (v3.1.1+), Fast_API Routes Guide (v0.24.2+)  
**Version**: v0.1.0 (December 2025)

## Overview

Surrogate dependencies are stand-in implementations of external services (GitHub, AWS, Stripe, etc.) that enable:
- **Offline-first development**: Run applications without external connectivity
- **Fast test execution**: No network latency or rate limits
- **Deterministic testing**: Predictable responses for reproducible tests
- **Security testing**: Test edge cases without hitting real APIs
- **Contract locking**: Captured responses document actual API behavior

Unlike stubs (hand-crafted minimal responses) or mocks (behavior verification), surrogates use **real recorded data** replayed to simulate the actual service. They act as an "evolved cache" that completely replaces the live source when needed.

This guide covers building surrogates using the class-driven Fast_API architecture with Type_Safe schemas.

## Quick Reference

When creating a surrogate service:
1. Create a `Surrogate__State__[Service]` class (Type_Safe) for in-memory state
2. Create `Schema__[Service]__*` classes for request/response models
3. Create `Routes__Surrogate__[Service]` class inheriting from `Fast_API__Routes`
4. Create `Surrogate__Service__[Service]` class inheriting from `Fast_API__Service`
5. Write comprehensive tests using shared test infrastructure

## Core Architecture

### Surrogate Service Structure

```
surrogate_services/
├── [service_name]/
│   ├── surrogate/
│   │   ├── Surrogate__Service__[Service].py      # Main service class
│   │   ├── Surrogate__State__[Service].py        # In-memory state
│   │   └── routes/
│   │       ├── Routes__Surrogate__[Service].py   # API routes
│   │       └── Routes__Surrogate__[Feature].py   # Feature-specific routes
│   ├── schemas/
│   │   ├── Schema__[Service]__Request.py         # Request models
│   │   └── Schema__[Service]__Response.py        # Response models
│   └── tests/
│       ├── test__Surrogate__Service__[Service].py
│       └── test__Routes__Surrogate__[Service].py
```

## Part 1: Designing State Classes

### State Class Pattern

Every surrogate needs an in-memory state store. Use Type_Safe for automatic initialization and type safety:

```python
from osbot_utils.type_safe.Type_Safe                                             import Type_Safe
from osbot_utils.type_safe.primitives.domains.identifiers.safe_str.Safe_Str__Key import Safe_Str__Key
from typing                                                                      import Dict, List

class Surrogate__State__GitHub(Type_Safe):                                       # In-memory state for GitHub surrogate
    secrets        : Dict[str, Dict[str, Dict]]                                  # repo_key -> {secret_name -> metadata}
    repositories   : Dict[str, Dict]                                             # repo_key -> repo_data
    workflows      : Dict[str, List[Dict]]                                       # repo_key -> [workflow_data]
    rate_limit     : Dict[str, int]                                              # rate limit tracking per endpoint
    public_key     : str = 'a1b2c3d4e5f6' + '0' * 52                             # 64 hex chars for NaCl
    
    def repo_key(self, owner: str, repo: str) -> str:                            # Helper to create consistent repo keys
        return f"{owner}/{repo}"
    
    def reset(self):                                                             # Reset state between tests
        self.secrets      = {}
        self.repositories = {}
        self.workflows    = {}
        self.rate_limit   = {}
        return self
```

### State Singleton Pattern

For surrogates used across multiple route classes:

```python
from osbot_utils.type_safe.Type_Safe import Type_Safe

class Surrogate__State__Manager(Type_Safe):                                      # Manages surrogate state lifecycle
    _github_state : Surrogate__State__GitHub = None                              # Lazy singleton
    
    @classmethod
    def github(cls) -> Surrogate__State__GitHub:                                 # Get or create GitHub state
        if cls._github_state is None:
            cls._github_state = Surrogate__State__GitHub()
        return cls._github_state
    
    @classmethod
    def reset_all(cls):                                                          # Reset all state (for test cleanup)
        if cls._github_state:
            cls._github_state.reset()
```

## Part 2: Schema Design

### Request Schemas

Design request schemas to match the real API's expected input:

```python
from osbot_utils.type_safe.Type_Safe                                                           import Type_Safe
from osbot_utils.type_safe.primitives.domains.git.github.safe_str.Safe_Str__GitHub__Repo_Owner import Safe_Str__GitHub__Repo_Owner
from osbot_utils.type_safe.primitives.domains.git.github.safe_str.Safe_Str__GitHub__Repo_Name  import Safe_Str__GitHub__Repo_Name
from osbot_utils.type_safe.primitives.domains.identifiers.safe_str.Safe_Str__Key               import Safe_Str__Key
from typing                                                                                    import Optional

class Schema__GitHub__Secret__Request(Type_Safe):                                # Request to interact with secrets
    owner       : Safe_Str__GitHub__Repo_Owner                                   # GitHub username or org
    repo        : Safe_Str__GitHub__Repo_Name                                    # Repository name
    secret_name : Safe_Str__Key                                                  # Name of the secret

class Schema__GitHub__Secret__Create(Type_Safe):                                 # Request to create/update secret
    owner           : Safe_Str__GitHub__Repo_Owner
    repo            : Safe_Str__GitHub__Repo_Name
    secret_name     : Safe_Str__Key
    encrypted_value : str                                                        # Base64 NaCl sealed box
```

### Response Schemas

Design response schemas with consistent patterns:

```python
from osbot_utils.type_safe.Type_Safe                                             import Type_Safe
from osbot_utils.type_safe.primitives.domains.identifiers.Timestamp_Now          import Timestamp_Now
from typing                                                                      import List, Optional

class Schema__Rate_Limit(Type_Safe):                                             # Standard rate limit response
    remaining : int = 4998
    limit     : int = 5000
    reset     : int = 0
    used      : int = 2

class Schema__Response__Context(Type_Safe):                                      # Standard response wrapper
    success     : bool                      = True
    status_code : int                       = 200
    errors      : List[str]
    messages    : List[str]
    rate_limit  : Schema__Rate_Limit

class Schema__GitHub__Secret(Type_Safe):                                         # Secret metadata
    name       : str
    created_at : str = ''
    updated_at : str = ''

class Schema__GitHub__Secrets__List__Response(Type_Safe):                        # List secrets response
    response_context : Schema__Response__Context
    response_data    : Dict[str, List[Schema__GitHub__Secret]]                   # {secrets: [...]}

class Schema__GitHub__Public_Key__Response(Type_Safe):                           # Public key response
    public_key : str
    algorithm  : str = 'NaCl/Curve25519/SealedBox'
    timestamp  : int
```

## Part 3: Route Implementation

### Route Class Structure

Convert procedural FastAPI routes to class-based Fast_API__Routes:

```python
from osbot_fast_api.api.routes.Fast_API__Routes                                  import Fast_API__Routes
from fastapi                                                                     import HTTPException
from typing                                                                      import Dict, Any

TAG__ROUTES_GITHUB_SURROGATE = 'github-surrogate'
ROUTES_PATHS__GITHUB_SURROGATE = [
    f'/{TAG__ROUTES_GITHUB_SURROGATE}/encryption/public-key'      ,
    f'/{TAG__ROUTES_GITHUB_SURROGATE}/secrets/list'               ,
    f'/{TAG__ROUTES_GITHUB_SURROGATE}/secrets/get'                ,
    f'/{TAG__ROUTES_GITHUB_SURROGATE}/secrets/create'             ,
    f'/{TAG__ROUTES_GITHUB_SURROGATE}/secrets/delete'             ,
]

class Routes__Surrogate__GitHub(Fast_API__Routes):
    tag : str = TAG__ROUTES_GITHUB_SURROGATE
    
    surrogate_state : Surrogate__State__GitHub                                   # Type_Safe auto-initializes
    
    def encryption__public_key(self) -> Schema__GitHub__Public_Key__Response:    # GET public key
        return Schema__GitHub__Public_Key__Response(
            public_key = self.surrogate_state.public_key ,
            algorithm  = 'NaCl/Curve25519/SealedBox'     ,
            timestamp  = Timestamp_Now()                 )
    
    def secrets__list(self, request: Schema__GitHub__Secret__Request             # POST list secrets
                      ) -> Schema__GitHub__Secrets__List__Response:
        repo_key     = self.surrogate_state.repo_key(request.owner, request.repo)
        secrets_dict = self.surrogate_state.secrets.get(repo_key, {})
        secrets_list = [Schema__GitHub__Secret(name       = name                        ,
                                               created_at = meta.get('created_at', '')  ,
                                               updated_at = meta.get('updated_at', '')  )
                        for name, meta in secrets_dict.items()]
        
        return Schema__GitHub__Secrets__List__Response(
            response_context = Schema__Response__Context(success     = True ,
                                                         status_code = 200  ),
            response_data    = dict(secrets = secrets_list)                  )
    
    def secrets__get(self, request: Schema__GitHub__Secret__Request              # POST get single secret
                     ) -> Dict[str, Any]:
        repo_key     = self.surrogate_state.repo_key(request.owner, request.repo)
        secrets_dict = self.surrogate_state.secrets.get(repo_key, {})
        secret_name  = str(request.secret_name)
        
        if secret_name not in secrets_dict:
            return dict(response_context = dict(success     = False                                ,
                                                status_code = 404                                  ,
                                                errors      = [f"Secret '{secret_name}' not found"],
                                                rate_limit  = Schema__Rate_Limit().obj()          ),
                        response_data    = {}                                                      )
        
        meta = secrets_dict[secret_name]
        return dict(response_context = dict(success     = True                      ,
                                            status_code = 200                       ,
                                            rate_limit  = Schema__Rate_Limit().obj()),
                    response_data    = dict(secret = dict(name       = secret_name              ,
                                                          created_at = meta.get('created_at', ''),
                                                          updated_at = meta.get('updated_at', ''))))
    
    def secrets__create(self, request: Schema__GitHub__Secret__Create            # POST create secret
                        ) -> Dict[str, Any]:
        repo_key    = self.surrogate_state.repo_key(request.owner, request.repo)
        secret_name = str(request.secret_name)
        
        if repo_key not in self.surrogate_state.secrets:
            self.surrogate_state.secrets[repo_key] = {}
        
        self.surrogate_state.secrets[repo_key][secret_name] = dict(
            created_at = '2024-01-15T10:30:00Z',
            updated_at = '2024-03-20T14:45:00Z')
        
        return dict(response_context = dict(success     = True                            ,
                                            status_code = 201                             ,
                                            messages    = [f"Secret '{secret_name}' created"],
                                            rate_limit  = Schema__Rate_Limit().obj()      ),
                    response_data    = dict(created = True)                               )
    
    def secrets__delete(self, request: Schema__GitHub__Secret__Request           # DELETE secret
                        ) -> Dict[str, Any]:
        repo_key     = self.surrogate_state.repo_key(request.owner, request.repo)
        secrets_dict = self.surrogate_state.secrets.get(repo_key, {})
        secret_name  = str(request.secret_name)
        deleted      = secret_name in secrets_dict
        
        if deleted:
            del self.surrogate_state.secrets[repo_key][secret_name]
        
        return dict(response_context = dict(success     = True                       ,
                                            status_code = 204 if deleted else 404    ,
                                            rate_limit  = Schema__Rate_Limit().obj() ),
                    response_data    = dict(deleted = deleted)                       )
    
    def setup_routes(self):                                                      # REQUIRED - register all routes
        self.add_route_get   (self.encryption__public_key)
        self.add_route_post  (self.secrets__list         )
        self.add_route_post  (self.secrets__get          )
        self.add_route_post  (self.secrets__create       )
        self.add_route_delete(self.secrets__delete       )
        return self
```

## Part 4: Service Class

### Surrogate Service Structure

Create the main service class that wires everything together:

```python
from osbot_fast_api.api.Fast_API__Service                                        import Fast_API__Service
from osbot_utils.type_safe.Type_Safe                                             import Type_Safe

class Surrogate__Service__GitHub(Fast_API__Service):
    service_name  : str = 'GitHub Surrogate Service'
    
    routes_github : Routes__Surrogate__GitHub                                    # Type_Safe auto-creates
    
    def setup_routes(self):                                                      # Register route classes
        self.routes_github.setup_routes()
        return self
    
    def setup(self):                                                             # Full service setup
        super().setup()
        self.setup_routes()
        return self
    
    def reset_state(self):                                                       # Reset for testing
        self.routes_github.surrogate_state.reset()
        return self
```

### Creating TestClient

For testing without network:

```python
from starlette.testclient import TestClient

def create_github_surrogate_client() -> TestClient:                              # Factory for test client
    with Surrogate__Service__GitHub() as service:
        service.setup()
        return TestClient(service.app())
```

## Part 5: Testing Patterns

### Test Class Structure

```python
from unittest                                                                    import TestCase
from osbot_utils.testing.Stdout                                                  import Stdout
from osbot_utils.utils.Objects                                                   import __

class Test__Routes__Surrogate__GitHub(TestCase):
    
    @classmethod
    def setUpClass(cls):
        cls.surrogate_service = Surrogate__Service__GitHub().setup()
        cls.test_client       = TestClient(cls.surrogate_service.app())
        cls.routes            = cls.surrogate_service.routes_github
    
    @classmethod
    def tearDownClass(cls):
        cls.surrogate_service.reset_state()
    
    def setUp(self):
        self.routes.surrogate_state.reset()                                      # Clean state per test
    
    def test__encryption__public_key(self):
        response = self.test_client.get('/github-surrogate/encryption/public-key')
        
        assert response.status_code == 200
        data = response.json()
        assert data['algorithm']  == 'NaCl/Curve25519/SealedBox'
        assert len(data['public_key']) == 64                                     # 64 hex chars
    
    def test__secrets__create_and_list(self):
        # Create a secret
        create_response = self.test_client.post(
            '/github-surrogate/secrets/create',
            json = dict(owner           = 'test-org'      ,
                        repo            = 'test-repo'     ,
                        secret_name     = 'API_KEY'       ,
                        encrypted_value = 'encrypted_data'))
        
        assert create_response.status_code == 200
        assert create_response.json()['response_data']['created'] is True
        
        # List secrets
        list_response = self.test_client.post(
            '/github-surrogate/secrets/list',
            json = dict(owner = 'test-org' ,
                        repo  = 'test-repo'))
        
        assert list_response.status_code == 200
        secrets = list_response.json()['response_data']['secrets']
        assert len(secrets) == 1
        assert secrets[0]['name'] == 'API_KEY'
    
    def test__secrets__get_not_found(self):
        response = self.test_client.post(
            '/github-surrogate/secrets/get',
            json = dict(owner       = 'test-org'    ,
                        repo        = 'test-repo'   ,
                        secret_name = 'NONEXISTENT' ))
        
        assert response.status_code == 200
        data = response.json()
        assert data['response_context']['success']     is False
        assert data['response_context']['status_code'] == 404
```

### Direct Route Testing

Test routes directly without HTTP:

```python
def test__routes_direct__secrets_create(self):
    with Schema__GitHub__Secret__Create() as request:
        request.owner           = 'my-org'
        request.repo            = 'my-repo'
        request.secret_name     = 'DB_PASSWORD'
        request.encrypted_value = 'base64_encrypted'
        
        response = self.routes.secrets__create(request)
        
        assert response['response_context']['success'] is True
        assert response['response_data']['created']    is True
        
        # Verify state was updated
        repo_key = self.routes.surrogate_state.repo_key('my-org', 'my-repo')
        assert 'DB_PASSWORD' in self.routes.surrogate_state.secrets[repo_key]
```

## Part 6: Advanced Patterns

### Simulating Rate Limits

```python
class Surrogate__State__With_Rate_Limit(Type_Safe):
    requests_remaining : int  = 5000
    requests_limit     : int  = 5000
    rate_limit_reset   : int  = 0
    
    def consume_request(self, count: int = 1) -> Schema__Rate_Limit:             # Track rate limit
        self.requests_remaining = max(0, self.requests_remaining - count)
        return Schema__Rate_Limit(
            remaining = self.requests_remaining                          ,
            limit     = self.requests_limit                              ,
            reset     = self.rate_limit_reset                            ,
            used      = self.requests_limit - self.requests_remaining    )
    
    def is_rate_limited(self) -> bool:
        return self.requests_remaining <= 0
```

### Simulating Errors

```python
class Surrogate__State__Error_Simulation(Type_Safe):
    force_error      : bool = False                                              # Force next request to fail
    error_status     : int  = 500
    error_message    : str  = 'Internal Server Error'
    error_after_n    : int  = 0                                                  # Fail after N successful requests
    request_count    : int  = 0
    
    def should_error(self) -> bool:
        self.request_count += 1
        if self.force_error:
            return True
        if self.error_after_n > 0 and self.request_count > self.error_after_n:
            return True
        return False
```

### Simulating Latency

```python
import asyncio
from osbot_utils.type_safe.Type_Safe import Type_Safe

class Surrogate__State__With_Latency(Type_Safe):
    latency_ms      : int  = 0                                                   # Simulated latency
    latency_enabled : bool = False
    
    async def simulate_latency(self):
        if self.latency_enabled and self.latency_ms > 0:
            await asyncio.sleep(self.latency_ms / 1000.0)
```

### Recording Mode (Capture Real Responses)

```python
from osbot_utils.type_safe.Type_Safe                                             import Type_Safe
from osbot_utils.helpers.Safe_Id                                                 import Safe_Id
import json
from pathlib                                                                     import Path

class Surrogate__Response__Recorder(Type_Safe):
    recording_enabled : bool = False
    recording_path    : str  = './surrogate_data'
    
    def record_response(self, endpoint: str    ,                                 # Save response for replay
                              params  : dict   ,
                              response: dict   ):
        if not self.recording_enabled:
            return
        
        path = Path(self.recording_path) / endpoint.replace('/', '_')
        path.mkdir(parents=True, exist_ok=True)
        
        filename = f"{Safe_Id()}_{hash(str(params)) % 10000}.json"
        filepath = path / filename
        
        with open(filepath, 'w') as f:
            json.dump(dict(params   = params  ,
                           response = response), f, indent=2)
```

## Part 7: Integration with Real Services

### Surrogate Mode Toggle

Design services to switch between real and surrogate:

```python
from osbot_utils.type_safe.Type_Safe import Type_Safe
from typing                          import Literal

class Service__GitHub__Client(Type_Safe):
    mode             : Literal['live', 'surrogate'] = 'live'
    live_client      : GitHub__Client                                            # Real API client
    surrogate_client : TestClient                                                # Surrogate client
    
    def get_client(self):                                                        # Return appropriate client
        if self.mode == 'surrogate':
            return self.surrogate_client
        return self.live_client
    
    def list_secrets(self, owner: str, repo: str):
        if self.mode == 'surrogate':
            response = self.surrogate_client.post(
                '/github-surrogate/secrets/list',
                json = dict(owner = owner, repo = repo))
            return response.json()
        return self.live_client.list_secrets(owner, repo)
```

### Environment-Based Configuration

```python
import os
from osbot_utils.type_safe.Type_Safe import Type_Safe

class Config__Surrogate(Type_Safe):
    use_surrogates : bool = False
    surrogate_path : str  = './surrogate_data'
    
    @classmethod
    def from_env(cls) -> 'Config__Surrogate':
        return cls(
            use_surrogates = os.environ.get('USE_SURROGATES', '').lower() == 'true',
            surrogate_path = os.environ.get('SURROGATE_PATH', './surrogate_data')  )
```

## Complete Example: GitHub Secrets Surrogate

Here's the full refactored version of the GitHub service surrogate:

### File: surrogate/Surrogate__State__GitHub.py

```python
from osbot_utils.type_safe.Type_Safe import Type_Safe
from typing                          import Dict, List

class Surrogate__State__GitHub(Type_Safe):
    secrets    : Dict[str, Dict[str, Dict]]                                      # repo_key -> {name -> metadata}
    public_key : str = 'a1b2c3d4e5f6' + '0' * 52                                # 64 hex NaCl key
    
    def repo_key(self, owner: str, repo: str) -> str:
        return f"{owner}/{repo}"
    
    def reset(self):
        self.secrets = {}
        return self
```

### File: schemas/Schema__GitHub__Secrets.py

```python
from osbot_utils.type_safe.Type_Safe                                                           import Type_Safe
from osbot_utils.type_safe.primitives.domains.git.github.safe_str.Safe_Str__GitHub__Repo_Owner import Safe_Str__GitHub__Repo_Owner
from osbot_utils.type_safe.primitives.domains.git.github.safe_str.Safe_Str__GitHub__Repo_Name  import Safe_Str__GitHub__Repo_Name
from osbot_utils.type_safe.primitives.domains.identifiers.safe_str.Safe_Str__Key               import Safe_Str__Key
from typing                                                                                    import List, Dict

class Schema__Rate_Limit(Type_Safe):
    remaining : int = 4998
    limit     : int = 5000
    reset     : int = 0
    used      : int = 2

class Schema__GitHub__Secret__Request(Type_Safe):
    owner       : Safe_Str__GitHub__Repo_Owner
    repo        : Safe_Str__GitHub__Repo_Name
    secret_name : Safe_Str__Key = None

class Schema__GitHub__Secret__Create(Type_Safe):
    owner           : Safe_Str__GitHub__Repo_Owner
    repo            : Safe_Str__GitHub__Repo_Name
    secret_name     : Safe_Str__Key
    encrypted_value : str = ''
```

### File: surrogate/routes/Routes__Surrogate__GitHub__Secrets.py

```python
from osbot_fast_api.api.routes.Fast_API__Routes                                  import Fast_API__Routes
from osbot_utils.type_safe.primitives.domains.identifiers.Timestamp_Now          import Timestamp_Now
from typing                                                                      import Dict, Any

TAG__ROUTES_GITHUB_SURROGATE = 'github-surrogate'
ROUTES_PATHS__GITHUB_SURROGATE = [
    f'/{TAG__ROUTES_GITHUB_SURROGATE}/encryption/public-key',
    f'/{TAG__ROUTES_GITHUB_SURROGATE}/secrets/list'         ,
    f'/{TAG__ROUTES_GITHUB_SURROGATE}/secrets/get'          ,
    f'/{TAG__ROUTES_GITHUB_SURROGATE}/secrets/create'       ,
    f'/{TAG__ROUTES_GITHUB_SURROGATE}/secrets/delete'       ,
]

class Routes__Surrogate__GitHub__Secrets(Fast_API__Routes):
    tag             : str = TAG__ROUTES_GITHUB_SURROGATE
    surrogate_state : Surrogate__State__GitHub                                   # Auto-initialized
    
    def encryption__public_key(self) -> Dict[str, Any]:
        return dict(public_key = self.surrogate_state.public_key ,
                    algorithm  = 'NaCl/Curve25519/SealedBox'     ,
                    timestamp  = int(Timestamp_Now())            )
    
    def secrets__list(self, payload: Schema__GitHub__Secret__Request
                      ) -> Dict[str, Any]:
        repo_key     = self.surrogate_state.repo_key(str(payload.owner), str(payload.repo))
        secrets_dict = self.surrogate_state.secrets.get(repo_key, {})
        secrets_list = [dict(name       = name                       ,
                             created_at = meta.get('created_at', '') ,
                             updated_at = meta.get('updated_at', '') )
                        for name, meta in secrets_dict.items()]
        
        return dict(response_context = dict(success     = True                      ,
                                            status_code = 200                       ,
                                            rate_limit  = Schema__Rate_Limit().obj()),
                    response_data    = dict(secrets = secrets_list)                 )
    
    def secrets__get(self, payload: Schema__GitHub__Secret__Request
                     ) -> Dict[str, Any]:
        repo_key     = self.surrogate_state.repo_key(str(payload.owner), str(payload.repo))
        secret_name  = str(payload.secret_name)
        secrets_dict = self.surrogate_state.secrets.get(repo_key, {})
        
        if secret_name not in secrets_dict:
            return dict(response_context = dict(success     = False                                ,
                                                status_code = 404                                  ,
                                                errors      = [f"Secret '{secret_name}' not found"],
                                                rate_limit  = Schema__Rate_Limit().obj()          ),
                        response_data    = {}                                                      )
        
        meta = secrets_dict[secret_name]
        return dict(response_context = dict(success     = True                      ,
                                            status_code = 200                       ,
                                            rate_limit  = Schema__Rate_Limit().obj()),
                    response_data    = dict(secret = dict(name       = secret_name              ,
                                                          created_at = meta.get('created_at', ''),
                                                          updated_at = meta.get('updated_at', ''))))
    
    def secrets__create(self, payload: Schema__GitHub__Secret__Create
                        ) -> Dict[str, Any]:
        repo_key    = self.surrogate_state.repo_key(str(payload.owner), str(payload.repo))
        secret_name = str(payload.secret_name)
        
        if repo_key not in self.surrogate_state.secrets:
            self.surrogate_state.secrets[repo_key] = {}
        
        self.surrogate_state.secrets[repo_key][secret_name] = dict(
            created_at = '2024-01-15T10:30:00Z',
            updated_at = '2024-03-20T14:45:00Z')
        
        return dict(response_context = dict(success     = True                             ,
                                            status_code = 201                              ,
                                            messages    = [f"Secret '{secret_name}' created"],
                                            rate_limit  = Schema__Rate_Limit().obj()       ),
                    response_data    = dict(created = True)                                )
    
    def secrets__delete(self, payload: Schema__GitHub__Secret__Request
                        ) -> Dict[str, Any]:
        repo_key     = self.surrogate_state.repo_key(str(payload.owner), str(payload.repo))
        secret_name  = str(payload.secret_name)
        secrets_dict = self.surrogate_state.secrets.get(repo_key, {})
        deleted      = secret_name in secrets_dict
        
        if deleted:
            del self.surrogate_state.secrets[repo_key][secret_name]
        
        return dict(response_context = dict(success     = True                       ,
                                            status_code = 204 if deleted else 404    ,
                                            rate_limit  = Schema__Rate_Limit().obj() ),
                    response_data    = dict(deleted = deleted)                       )
    
    def setup_routes(self):
        self.add_route_get   (self.encryption__public_key)
        self.add_route_post  (self.secrets__list         )
        self.add_route_post  (self.secrets__get          )
        self.add_route_post  (self.secrets__create       )
        self.add_route_delete(self.secrets__delete       )
        return self
```

### File: surrogate/Surrogate__Service__GitHub.py

```python
from osbot_fast_api.api.Fast_API__Service import Fast_API__Service
from starlette.testclient                 import TestClient

class Surrogate__Service__GitHub(Fast_API__Service):
    service_name   : str = 'GitHub Surrogate Service'
    routes_secrets : Routes__Surrogate__GitHub__Secrets
    
    def setup_routes(self):
        self.routes_secrets.setup_routes()
        return self
    
    def setup(self):
        super().setup()
        self.setup_routes()
        return self
    
    def reset_state(self):
        self.routes_secrets.surrogate_state.reset()
        return self
    
    def create_client(self) -> TestClient:
        return TestClient(self.app())


def create_github_surrogate_client() -> TestClient:                              # Factory function
    with Surrogate__Service__GitHub() as service:
        service.setup()
        return service.create_client()

def reset_github_surrogate_state():                                              # Reset for tests
    with Surrogate__Service__GitHub() as service:
        service.reset_state()
```

## Critical Rules

### ALWAYS:
- Use Type_Safe classes for ALL state and schemas (NEVER Pydantic)
- Implement `setup_routes()` method in route classes
- Implement `reset()` method in state classes for test cleanup
- Follow double underscore naming for path parameters
- Return consistent response structures (response_context + response_data)
- Test with shared FastAPI test infrastructure
- Document paths in ROUTES_PATHS__ constant

### NEVER:
- Use Pydantic BaseModel
- Use FastAPI decorators (@app.get, @app.post) directly
- Store state in module-level variables without Type_Safe wrapper
- Create new FastAPI apps in tests (use TestClient with surrogate service)
- Use raw primitives when Safe types exist
- Skip error handling or state validation

## Terminology Reference

| Term | Definition |
|------|------------|
| **Surrogate** | Stand-in for real service using captured/realistic data |
| **Stub** | Hand-crafted minimal response (avoid this term) |
| **Mock** | Behavior verification tool (different purpose) |
| **Surrogate State** | In-memory Type_Safe class holding service data |
| **Surrogate Service** | Fast_API__Service wrapping surrogate routes |
| **Recording Mode** | Capturing real API responses for replay |

## Testing Checklist

- [ ] Test class inherits from TestCase
- [ ] Use setUpClass for surrogate service setup
- [ ] Reset state in setUp for test isolation
- [ ] Test each route method directly
- [ ] Test via TestClient for HTTP integration
- [ ] Test error cases (404, validation errors)
- [ ] Test state mutations (create, update, delete)
- [ ] Verify state cleanup between tests
- [ ] Test with realistic data scenarios

## Summary

This guide provides patterns for building surrogate dependencies using Fast_API and Type_Safe:

1. **State Classes**: Type_Safe classes for in-memory state with reset capability
2. **Schema Classes**: Type_Safe request/response models matching real APIs
3. **Route Classes**: Fast_API__Routes with class-based organization
4. **Service Classes**: Fast_API__Service wiring routes and state
5. **Testing**: Comprehensive patterns for isolated, deterministic tests

The class-driven architecture enables:
- Type-safe state management
- Clean separation of concerns
- Easy testing without network dependencies
- Consistent API response patterns
- Simple state reset for test isolation

Surrogates differ from stubs/mocks by using **real captured data** to simulate services, enabling true offline-first development and acting as a contract lock for API behavior.

For Type_Safe details, refer to:
- "Type_Safe & Python Formatting Guide for LLMs v3.1.1"
- "OSBot-Utils Safe Primitives Complete Reference Guide v3.28.0"
- "OSBot-Fast-API Routes Development Guide v0.24.2"
- "Surrogate Dependencies: Simulating Backends for Offline-First Development" (Dinis Cruz)