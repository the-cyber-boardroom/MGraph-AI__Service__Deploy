# Deploy Service MVP - Phase 1 Technical Debrief

**Version**: v0.7.3

## Executive Summary

Phase 1 of the Deploy Service MVP delivers a secure pass-through proxy for GitHub Secrets management. The service acts as an orchestration layer between clients and the GitHub Service, providing a unified API for credential-protected operations without ever handling decrypted secrets.

**Key Achievement**: Beyond the 6 API endpoints, we established a powerful testing architecture using the GitHub Service's surrogate system, enabling full integration tests that run entirely in-memory with zero external dependencies.

---

## 1. The Why: Motivation and Goals

### 1.1 The Problem We're Solving

Clients need to manage GitHub repository secrets programmatically, but doing so securely requires:

1. **Credential Protection**: GitHub Personal Access Tokens (PATs) must never be exposed in transit or at rest
2. **Secret Value Protection**: The actual secret values being stored must also be encrypted
3. **Centralized Operations**: Multiple deployment workflows need a single point of control
4. **Audit Trail**: All operations should flow through a controlled service layer

### 1.2 Why a Separate Deploy Service?

The GitHub Service already handles GitHub API interactions. Why add another layer?

```
┌─────────────────────────────────────────────────────────────────────────┐
│                           WITHOUT DEPLOY SERVICE                         │
│                                                                          │
│   Client A ──┐                                                           │
│   Client B ──┼──► GitHub Service ──► GitHub API                          │
│   Client C ──┘                                                           │
│                                                                          │
│   Problem: Each client must understand GitHub Service's internal API     │
│            No orchestration layer for multi-step workflows               │
│            No unified error handling or rate limit management            │
└─────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────┐
│                           WITH DEPLOY SERVICE                            │
│                                                                          │
│   Client A ──┐                                                           │
│   Client B ──┼──► Deploy Service ──► GitHub Service ──► GitHub API       │
│   Client C ──┘                                                           │
│                                                                          │
│   Benefits: Unified API for deployment operations                        │
│             Workflow orchestration (Phase 2)                             │
│             Single point for auth, rate limits, audit                    │
│             Clients isolated from GitHub Service internals               │
└─────────────────────────────────────────────────────────────────────────┘
```

### 1.3 Security Model: Pass-Through Encryption

A critical architectural decision: **the Deploy Service never decrypts anything**.

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        ENCRYPTION FLOW                                   │
│                                                                          │
│  ┌──────────┐    ┌────────────────┐    ┌────────────────┐    ┌────────┐ │
│  │  Client  │    │ Deploy Service │    │ GitHub Service │    │ GitHub │ │
│  └────┬─────┘    └───────┬────────┘    └───────┬────────┘    └────┬───┘ │
│       │                  │                     │                  │     │
│       │ 1. Get public key│                     │                  │     │
│       │─────────────────►│ 2. Forward          │                  │     │
│       │                  │────────────────────►│                  │     │
│       │◄─────────────────┼─────────────────────│                  │     │
│       │   NaCl public key│                     │                  │     │
│       │                  │                     │                  │     │
│       │ 3. Encrypt PAT   │                     │                  │     │
│       │    locally with  │                     │                  │     │
│       │    public key    │                     │                  │     │
│       │                  │                     │                  │     │
│       │ 4. Send encrypted│ 5. Pass through     │ 6. Decrypt with  │     │
│       │    PAT + request │    unchanged        │    private key   │     │
│       │─────────────────►│────────────────────►│─────────────────►│     │
│       │                  │                     │    Use raw PAT   │     │
│       │                  │                     │                  │     │
│  └────┴─────┘    └───────┴────────┘    └───────┴────────┘    └────┴───┘ │
│                                                                          │
│  Deploy Service sees: encrypted blob (cannot decrypt)                    │
│  GitHub Service sees: encrypted blob → decrypts → raw PAT               │
│  Only GitHub Service has the private key                                 │
└─────────────────────────────────────────────────────────────────────────┘
```

This design means:
- Deploy Service compromise doesn't expose credentials
- Credentials are encrypted end-to-end (client ↔ GitHub Service)
- Deploy Service can be deployed in less trusted environments

---

## 2. The What: What We Built

### 2.1 API Endpoints

| Method | Endpoint | Purpose |
|--------|----------|---------|
| GET | `/public-keys/github` | Fetch GitHub Service's NaCl public key for client-side encryption |
| POST | `/operations/github/secrets/list` | List all secrets in a repository |
| POST | `/operations/github/secrets/get` | Get metadata for a specific secret |
| POST | `/operations/github/secrets/exists` | Check if a secret exists |
| POST | `/operations/github/secrets/create` | Create or update a secret |
| POST | `/operations/github/secrets/delete` | Delete a secret |

### 2.2 Project Structure

```
mgraph_ai_service_deploy/
├── config.py                           # GITHUB_SERVICE_URL configuration
├── version                             # v0.8.0
│
├── fast_api/
│   ├── Deploy__Service__Fast_API.py    # Main FastAPI application
│   ├── lambda_handler.py               # AWS Lambda entry point
│   └── routes/
│       ├── Routes__Public_Keys.py      # GET /public-keys/github
│       └── Routes__Operations__GitHub__Secrets.py  # All secrets operations
│
├── schemas/
│   ├── common/
│   │   ├── Safe_Str__Encrypted_Value.py      # Encrypted value validation
│   │   ├── Safe_Str__GitHub__Secret_Name.py  # Secret name validation
│   │   ├── Schema__Response__Operation.py    # Unified response format
│   │   └── Schema__Target__GitHub__Repo.py   # Owner/repo targeting
│   └── github/
│       ├── Schema__Request__GitHub__Secrets__List.py
│       ├── Schema__Request__GitHub__Secrets__Get.py
│       ├── Schema__Request__GitHub__Secrets__Exists.py
│       ├── Schema__Request__GitHub__Secrets__Create.py
│       └── Schema__Request__GitHub__Secrets__Delete.py
│
├── services/
│   ├── Service__Public_Keys.py         # Fetch public keys from downstream
│   └── Service__GitHub__Secrets.py     # GitHub secrets business logic
│
└── tests/
    ├── unit/
    │   ├── Deploy__Service__Fast_API__Test_Objs.py  # Test infrastructure
    │   ├── services/
    │   │   ├── test_Service__Public_Keys.py
    │   │   └── test_Service__GitHub__Secrets.py
    │   └── fast_api/routes/
    │       ├── test_Routes__Public_Keys.py
    │       └── test_Routes__Operations__GitHub__Secrets.py
    └── integration/
        └── test_Routes__Operations__GitHub__Secrets.py
```

### 2.3 Schema Design

All request schemas follow a consistent pattern:

```python
class Schema__Request__GitHub__Secrets__Create(Type_Safe):
    encrypted_pat   : Safe_Str__Encrypted_Value      # NaCl-encrypted PAT (base64)
    target          : Schema__Target__GitHub__Repo   # owner + repo
    secret_name     : Safe_Str__GitHub__Secret_Name  # Validated secret name
    encrypted_value : Safe_Str__Encrypted_Value      # NaCl-encrypted secret value
```

The `Safe_Str__Encrypted_Value` type ensures:
- Value is valid base64
- Decoded length ≥ 48 bytes (NaCl SealedBox overhead)
- This catches "fake" encrypted values early

### 2.4 Unified Response Format

All operations return a consistent response:

```python
class Schema__Response__Operation(Type_Safe):
    success   : bool                    # Did the operation succeed?
    operation : str                     # e.g., "github:secrets:create"
    data      : Optional[Dict]          # Operation-specific data
    error     : Optional[str]           # Error message if failed
    duration  : float                   # Execution time in seconds
```

---

## 3. The How: Implementation Approach

### 3.1 Service Layer Pattern

Routes are thin HTTP handlers; services contain business logic:

```python
# Routes: HTTP layer only
class Routes__Operations__GitHub__Secrets(Fast_API__Routes):
    service_github_secrets: Service__GitHub__Secrets

    def create(self, request: Schema__Request__GitHub__Secrets__Create):
        return self.service_github_secrets.create_secret(
            encrypted_pat   = request.encrypted_pat,
            target          = request.target,
            secret_name     = request.secret_name,
            encrypted_value = request.encrypted_value
        )

# Services: Business logic
class Service__GitHub__Secrets(Type_Safe):
    http_client: Optional[Any] = None  # Injected for testing

    def create_secret(self, encrypted_pat, target, secret_name, encrypted_value):
        # Transform to GitHub Service format
        payload = {
            "encrypted_pat": str(encrypted_pat),
            "owner"        : target.owner,
            "repo"         : target.repo,
            "secret_name"  : str(secret_name),
            "secret_value" : str(encrypted_value)
        }
        
        # Call GitHub Service
        response = self._call_github_service('/github-secrets-repo/create', payload)
        
        # Build unified response
        return Schema__Response__Operation(
            success   = response.get('status') == 'success',
            operation = 'github:secrets:create',
            data      = response.get('data'),
            error     = response.get('error')
        )
```

### 3.2 Dependency Injection for Testing

Services accept an optional `http_client` parameter:

```python
class Service__GitHub__Secrets(Type_Safe):
    http_client: Optional[Any] = None

    def _call_github_service(self, endpoint: str, payload: dict):
        if self.http_client:
            # Test mode: use injected TestClient
            response = self.http_client.post(endpoint, json=payload)
            return response.json()
        else:
            # Production: use real HTTP
            url = f"{GITHUB_SERVICE_URL}{endpoint}"
            response = requests.post(url, json=payload, headers=...)
            return response.json()
```

This allows tests to inject a `TestClient` pointing at a local GitHub Service instance.

---

## 4. The Power of In-Memory Testing with GitHub Surrogate

This is perhaps the most significant technical achievement of Phase 1.

### 4.1 The Testing Challenge

Traditional approaches to testing services that depend on external APIs:

| Approach | Problems |
|----------|----------|
| **Mock the HTTP client** | Doesn't test real code paths; mocks can drift from reality |
| **Mock the service layer** | Same problem; you're testing your mocks, not your code |
| **Use real GitHub API** | Slow, requires credentials, rate limited, non-deterministic |
| **Record/replay (VCR)** | Recordings go stale; edge cases hard to reproduce |

### 4.2 Our Solution: Three-Layer Stack

We run **real code at every layer**, with only the external API mocked:

```
┌─────────────────────────────────────────────────────────────────────────┐
│                     TEST EXECUTION ARCHITECTURE                          │
│                                                                          │
│  ┌─────────────────────────────────────────────────────────────────┐    │
│  │                        TEST CODE                                 │    │
│  │   test_Service__GitHub__Secrets.py                               │    │
│  │   - Creates secrets via Deploy Service                           │    │
│  │   - Verifies via surrogate state inspection                      │    │
│  └─────────────────────────────────────┬───────────────────────────┘    │
│                                        │                                 │
│                                        │ TestClient (in-memory HTTP)     │
│                                        ▼                                 │
│  ┌─────────────────────────────────────────────────────────────────┐    │
│  │                    DEPLOY SERVICE (Real Code)                    │    │
│  │   Deploy__Service__Fast_API                                      │    │
│  │   - Routes__Operations__GitHub__Secrets                          │    │
│  │   - Service__GitHub__Secrets                                     │    │
│  │   - All production code paths executed                           │    │
│  └─────────────────────────────────────┬───────────────────────────┘    │
│                                        │                                 │
│                                        │ TestClient (in-memory HTTP)     │
│                                        ▼                                 │
│  ┌─────────────────────────────────────────────────────────────────┐    │
│  │                   GITHUB SERVICE (Real Code)                     │    │
│  │   GitHub_Service__Fast_API (from mgraph-ai-service-github)       │    │
│  │   - NaCl encryption/decryption                                   │    │
│  │   - Request validation                                           │    │
│  │   - GitHub API client                                            │    │
│  │   - All production code paths executed                           │    │
│  └─────────────────────────────────────┬───────────────────────────┘    │
│                                        │                                 │
│                                        │ Requests Session (injected)     │
│                                        ▼                                 │
│  ┌─────────────────────────────────────────────────────────────────┐    │
│  │                  GITHUB API SURROGATE (Mock)                     │    │
│  │   GitHub__API__Surrogate                                         │    │
│  │   - In-memory state for repos, secrets, public keys              │    │
│  │   - Simulates GitHub API responses                               │    │
│  │   - Supports error scenarios (401, 403, 429, etc.)               │    │
│  │   - State directly inspectable by tests                          │    │
│  └─────────────────────────────────────────────────────────────────┘    │
│                                                                          │
│  EVERYTHING ABOVE THE SURROGATE IS REAL PRODUCTION CODE                  │
└─────────────────────────────────────────────────────────────────────────┘
```

### 4.3 What This Enables

**1. Full Integration Tests Without Network**
```python
def test_create_secret_updates_state(self):
    # Call Deploy Service (real code)
    result = self.service.create_secret(
        encrypted_pat   = self.test_pat,
        target          = self.target,
        secret_name     = 'MY_SECRET',
        encrypted_value = self.encrypted_value
    )
    
    # Verify via surrogate state (direct inspection)
    state = self.surrogate_context.surrogate.state
    secret = state.get_repo_secret('test-org', 'test-repo', 'MY_SECRET')
    assert secret is not None
    assert secret.name == 'MY_SECRET'
```

**2. Error Scenario Testing**
```python
def test_expired_pat_returns_401(self):
    expired_pat = encrypt_pat_for_tests(
        self.github_client,
        self.surrogate_context.expired_pat()  # Surrogate knows this PAT is "expired"
    )
    
    result = self.service.list_secrets(
        encrypted_pat = expired_pat,
        target        = self.target
    )
    
    assert result.success is False
    assert '401' in result.error
```

**3. Rate Limit Testing**
```python
def test_rate_limited_pat_returns_429(self):
    rate_limited_pat = encrypt_pat_for_tests(
        self.github_client,
        self.surrogate_context.rate_limited_pat()
    )
    
    result = self.service.list_secrets(...)
    assert result.success is False
    assert 'rate limit' in result.error.lower()
```

**4. State Verification**
```python
def test_delete_removes_from_state(self):
    # Create
    self.service.create_secret(...)
    
    # Verify exists
    state = self.surrogate_context.surrogate.state
    assert state.get_repo_secret('owner', 'repo', 'SECRET') is not None
    
    # Delete
    self.service.delete_secret(...)
    
    # Verify removed
    assert state.get_repo_secret('owner', 'repo', 'SECRET') is None
```

### 4.4 Surrogate PAT Types

The surrogate provides various PAT types for testing different scenarios:

```python
surrogate_context.admin_pat()         # Full access - all operations succeed
surrogate_context.repo_write_pat()    # Can read/write secrets
surrogate_context.repo_read_pat()     # Read-only - writes return 403
surrogate_context.expired_pat()       # Returns 401 Unauthorized
surrogate_context.rate_limited_pat()  # Returns 429 Too Many Requests
surrogate_context.invalid_pat()       # Returns 401 Bad Credentials
surrogate_context.no_scopes_pat()     # Returns 403 Forbidden (insufficient scopes)
```

### 4.5 Why This Matters

| Traditional Mocking | Surrogate Architecture |
|---------------------|------------------------|
| Tests mock behavior | Tests exercise real code |
| Mocks can drift from implementation | Code changes break tests appropriately |
| Edge cases require mock setup | Edge cases built into surrogate |
| Can't verify side effects | Direct state inspection |
| Tests pass but production fails | If tests pass, production likely works |

The surrogate architecture gives us **confidence** that our tests reflect reality.

---

## 5. Lessons Learned

### 5.1 The PAT Encryption Validation Issue

**The Problem**

Initial tests used a simple base64 string as a "test PAT":
```python
cls.test_pat = 'SGVsbG9Xb3JsZA=='  # base64("HelloWorld") = 10 bytes
```

This passed through Deploy Service but failed at GitHub Service with a cryptic validation error.

**Root Cause**

The `Safe_Str__Encrypted_Value` schema requires decoded length ≥ 48 bytes because NaCl SealedBox encryption adds overhead:
- 32 bytes: ephemeral public key
- 16 bytes: Poly1305 authentication tag
- N bytes: ciphertext

A valid encrypted value is always at least 48 bytes. Our 10-byte test value was invalid.

**The Solution**

Tests must encrypt PATs using the actual encryption flow:

```python
def encrypt_pat_for_tests(github_client: TestClient, raw_pat: str) -> str:
    """Encrypt a raw PAT using the GitHub Service's public key."""
    # 1. Get public key from GitHub Service
    response = github_client.get('/encryption/public-key')
    public_key_hex = response.json()['public_key']
    
    # 2. Encrypt with NaCl SealedBox
    pub_key_bytes = bytes.fromhex(public_key_hex)
    nacl_pub_key  = PublicKey(pub_key_bytes)
    sealed_box    = SealedBox(nacl_pub_key)
    encrypted     = sealed_box.encrypt(raw_pat.encode())
    
    # 3. Base64 encode for transport
    return base64.b64encode(encrypted).decode()
```

**Key Insight**: Tests must follow the same encryption flow as production clients. This is actually a feature, not a bug—it validates that the encryption flow works end-to-end.

### 5.2 NaCl Key Generation Order

**The Problem**

Tests were failing because the GitHub Service couldn't decrypt PATs.

**Root Cause**

NaCl keys must be set as environment variables **before** the GitHub Service starts:

```python
# WRONG: Keys set after service starts
github_service = GitHub_Service__Fast_API().setup()
create_and_set_nacl_keys()  # Too late! Service already cached empty keys

# RIGHT: Keys set before service starts
create_and_set_nacl_keys()  # Set env vars first
github_service = GitHub_Service__Fast_API().setup()  # Service reads keys during setup
```

**Key Insight**: Service initialization order matters. Dependencies (like encryption keys) must be configured before services that use them.

### 5.3 Test State Management

**The Problem**

Tests were interfering with each other. A secret created in `test_A` was visible in `test_B`.

**Initial Approach**

Reset surrogate state before each test:
```python
def setUp(self):
    reset_surrogate_state(self.surrogate_context)
    self.surrogate_context.add_repo('owner', 'repo')
```

**Optimized Approach**

For many test classes, state accumulation is acceptable:
```python
@classmethod
def setUpClass(cls):
    # Setup once, state accumulates
    cls.surrogate_context.add_repo('owner', 'repo')

def test_list_secrets(self):
    # Use unique names to avoid conflicts
    secret_names = [s['name'] for s in result.data['secrets']]
    assert 'MY_UNIQUE_SECRET' in secret_names  # Not: len(secrets) == 1
```

**Key Insight**: Test assertions should be robust to accumulated state. Check for presence (`in`) rather than exact counts.

### 5.4 Import Path Consistency

**The Problem**

Tests failed with `ModuleNotFoundError` due to inconsistent import paths.

**Root Cause**

Mixing absolute and relative imports:
```python
# Sometimes used
from mgraph_ai_service_deploy.tests.unit.Deploy__Service__Fast_API__Test_Objs import ...

# Other times used  
from tests.unit.Deploy__Service__Fast_API__Test_Objs import ...
```

**Solution**

Standardize on relative imports within the test package:
```python
from tests.unit.Deploy__Service__Fast_API__Test_Objs import create_test_services
```

**Key Insight**: Pick an import convention and stick with it. The shorter path is usually preferable.

---

## 6. Test Coverage Summary

| Test File | Tests | Coverage |
|-----------|-------|----------|
| `test_Service__Public_Keys.py` | 7 | Service layer for public key fetching |
| `test_Service__GitHub__Secrets.py` | 15 | Service layer for all secrets operations |
| `test_Routes__Public_Keys.py` | 8 | Route layer for public keys |
| `test_Routes__Operations__GitHub__Secrets.py` | 22 | Route layer for secrets operations |
| `test_Routes__Operations__GitHub__Secrets.py` (integration) | 16 | Full HTTP client integration |
| **Total** | **68** | |

All tests exercise real code paths through the surrogate architecture.

---

## 7. Performance Characteristics

Because everything runs in-memory:

| Metric | Value |
|--------|-------|
| Full test suite | < 2 seconds |
| Individual test | < 50ms |
| No network calls | ✓ |
| No external dependencies | ✓ |
| Parallelizable | ✓ |

---

## 8. What's Next: Phase 2 Preview

Phase 2 will add workflow execution capabilities:

1. **`/execute` endpoint**: Execute a workflow file containing multiple operations
2. **`/execute/plan` endpoint**: Dry-run preview of what a workflow would do
3. **Workflow schemas**: Define credential sets and operation sequences
4. **`Service__Workflow__Executor`**: Parse and execute workflows

The surrogate architecture established in Phase 1 will make testing complex multi-step workflows straightforward.

---

## 9. Conclusion

Phase 1 delivered a secure, well-tested foundation for the Deploy Service. The key technical achievements are:

1. **Pass-through security model**: Credentials never decrypted by Deploy Service
2. **Surrogate testing architecture**: Full integration tests without external dependencies
3. **Clean separation**: Routes handle HTTP; services handle logic
4. **Type-safe schemas**: Validation at the boundary catches errors early

The investment in the surrogate testing architecture will pay dividends as we add more complex functionality in Phase 2.